
mod sampling;
mod builder;

pub use self::builder::SurfaceBuilder;

use std::io;
use std::slice;

use ::cgmath::{Vector2, Vector3};
use ::nearest_kdtree::KdTree;
use ::nearest_kdtree::distance::squared_euclidean;

use super::scene::Scene;

type Iter<'a> = slice::Iter<'a, Surfel>;
type IterMut<'a> = slice::IterMut<'a, Surfel>;
//type WithinSphereSurfelIter<'a> = iter::Filter<slice::IterMut<'a, Surfel>>;

/// Represents the surface of a mesh as a point-based model
pub struct Surface {
    pub samples: Vec<Surfel>,
    pub spatial_idx: KdTree<usize, [f64; 3]>
}

/// Represents an element of the surface of an object
pub struct Surfel {
    pub position: Vector3<f32>,
    pub normal: Vector3<f32>,
    pub texcoords: Vector2<f32>,
    /// Index of the entity in the scene that the triangle that this surfel was generated from belongs to
    pub entity_idx: usize,
    /// Deterioration rate of the probability of a gammaton moving further in a straight line
    #[allow(dead_code)]
    pub delta_straight: f32,
    /// Deterioration rate of the probability of a gammaton moving in a piecewise approximated parabolic path
    #[allow(dead_code)]
    pub delta_parabolic: f32,
    /// Deterioration rate of the probability of a gammaton flowing in a tangent direction
    #[allow(dead_code)]
    pub delta_flow: f32,
    /// Holds the amount of substances as numbers in the interval 0..1
    pub substances: Vec<f32>,
    /// Weights for the transport of substances from a settled ton to a surfel
    pub deposition_rates: Vec<f32>
}

impl Surface {
    pub fn dump<S : io::Write>(&self, sink: &mut S) -> io::Result<usize> {
        let mut written : usize = 0;

        written += sink.write("# Surface Model\n".as_bytes())?;
        written += sink.write("# Generated by surf.rs\n\n".as_bytes())?;

        written += sink.write("g surface\n\n".as_bytes())?;

        for &point in self.samples.iter().map(|s| &s.position) {
            // Write all the points as vertices
            let vertex_line = format!("v {} {} {}\n", point.x, point.y, point.z);
            written += sink.write(vertex_line.as_bytes())?;
        }

        written += sink.write("\n".as_bytes())?;

        // OBJ indices are 1-based, hence +1
        for idx in (0+1)..(self.samples.len()+1) {
            // Write points as 1-dimensional faces
            let face_line = format!("f {}\n", idx);
            written += sink.write(face_line.as_bytes())?;
        }

        Ok(written)
    }

    pub fn nearest_mut<'a>(&'a mut self, from: Vector3<f32>) -> &'a mut Surfel {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        &mut self.samples[nearest_idx]
    }

    pub fn nearest<'a>(&'a self, from: Vector3<f32>) -> &'a Surfel {
        assert!(!self.samples.is_empty());

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let (_, &nearest_idx) = self.spatial_idx.nearest(&[x, y, z], 1, &squared_euclidean).unwrap()[0];
        &self.samples[nearest_idx]
    }

    pub fn nearest_n<'a>(&'a self, from: Vector3<f32>, count: usize) -> Vec<(f32, &'a Surfel)> {
        assert!(self.samples.len() >= count);

        let x = from.x as f64;
        let y = from.y as f64;
        let z = from.z as f64;

        let nearest_idxs = self.spatial_idx.nearest(&[x, y, z], count, &squared_euclidean).unwrap();

        nearest_idxs.iter()
            .map(|n| (n.0 as f32, &self.samples[*n.1]))
            .collect()
    }

    pub fn iter<'a>(&'a self) -> Iter {
        self.samples.iter()
    }

    pub fn find_within_sphere<'a>(&'a self, center: Vector3<f32>, radius: f32) -> Vec<&'a Surfel> {
        let radius_sqr = (radius * radius) as f64;

        self.spatial_idx.within(
            &[center.x as f64, center.y as f64, center.z as f64],
            radius_sqr,
            &squared_euclidean
        ).unwrap().iter().map(move |&(_, &idx)| &self.samples[idx]).collect()
    }

    pub fn iter_mut<'a>(&'a mut self) -> IterMut {
        self.samples.iter_mut()
    }

    pub fn find_within_sphere_indexes(&self, center: Vector3<f32>, radius: f32) -> Vec<usize> {
        let radius_sqr = (radius * radius) as f64;

        self.spatial_idx.within(
            &[center.x as f64, center.y as f64, center.z as f64],
            radius_sqr,
            &squared_euclidean
        ).unwrap().iter().map(move |&(_, &idx)| idx).collect()
    }
}

