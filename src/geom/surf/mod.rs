
mod sampling;
mod builder;

pub use self::builder::SurfaceBuilder;

use std::io;
use std::slice;

use ::cgmath::{Vector2, Vector3};
use ::cgmath::prelude::*;
use ::kdtree::kdtree::{Kdtree, KdtreePointTrait};

use super::scene::Scene;

type Iter<'a> = slice::Iter<'a, Surfel>;
type BoxedIter<'a> = Box<Iterator<Item = &'a Surfel> + 'a>;

type IterMut<'a> = slice::IterMut<'a, Surfel>;
type BoxedIterMut<'a> = Box<Iterator<Item = &'a mut Surfel> + 'a>;
//type WithinSphereSurfelIter<'a> = iter::Filter<slice::IterMut<'a, Surfel>>;

/// Represents the surface of a mesh as a point-based model
pub struct Surface {
    pub samples: Vec<Surfel>,
    pub spatial_idx: Kdtree<SurfelIndex>
}

/// Represents an element of the surface of an object
pub struct Surfel {
    pub position: Vector3<f32>,
    pub texcoords: Vector2<f32>,
    /// Index of the entity in the scene that the triangle that this surfel was generated from belongs to
    pub entity_idx: usize,
    /// Deterioration rate of the probability of a gammaton moving further in a straight line
    #[allow(dead_code)]
    delta_straight: f32,
    /// Deterioration rate of the probability of a gammaton moving in a piecewise approximated parabolic path
    #[allow(dead_code)]
    delta_parabolic: f32,
    /// Deterioration rate of the probability of a gammaton flowing in a tangent direction
    #[allow(dead_code)]
    delta_flow: f32,
    /// Holds the amount of substances as numbers in the interval 0..1
    pub substances: Vec<f32>
}

/// Lightweight spatial index for the surfel
#[derive(PartialEq, Copy, Clone)]
pub struct SurfelIndex {
    position: [f64; 3],
    idx: Option<usize>
}

impl KdtreePointTrait for SurfelIndex {
    #[inline]
    fn dims(&self) -> &[f64] {
        &self.position
    }
}

impl Surface {
    pub fn dump<S : io::Write>(&self, sink: &mut S) -> io::Result<usize> {
        let mut written : usize = 0;

        written += sink.write("# Surface Model\n".as_bytes())?;
        written += sink.write("# Generated by surf.rs\n\n".as_bytes())?;

        written += sink.write("g surface\n\n".as_bytes())?;

        for &point in self.samples.iter().map(|s| &s.position) {
            // Write all the points as vertices
            let vertex_line = format!("v {} {} {}\n", point.x, point.y, point.z);
            written += sink.write(vertex_line.as_bytes())?;
        }

        written += sink.write("\n".as_bytes())?;

        // OBJ indices are 1-based, hence +1
        for idx in (0+1)..(self.samples.len()+1) {
            // Write points as 1-dimensional faces
            let face_line = format!("f {}\n", idx);
            written += sink.write(face_line.as_bytes())?;
        }

        Ok(written)
    }

    pub fn nearest<'a>(&'a mut self, from: Vector3<f32>) -> &'a mut Surfel {
        assert!(!self.samples.is_empty());

        let SurfelIndex { idx: nearest_idx, position: _ } = {
            let x = from.x as f64;
            let y = from.y as f64;
            let z = from.z as f64;

            let lookup_idx = SurfelIndex {
                position: [x, y, z],
                idx: None
            };

            self.spatial_idx.nearest_search(&lookup_idx)
        };

        &mut self.samples[nearest_idx.unwrap()]
    }

    pub fn iter<'a>(&'a self) -> Iter {
        self.samples.iter()
    }

    pub fn find_within_sphere<'a>(&'a self, center: Vector3<f32>, radius: f32) -> BoxedIter {
        let radius_sqr = radius * radius;
        Box::new(
            self.samples.iter()
                .filter(move |s| s.position.distance2(center) < radius_sqr)
        )
    }

    pub fn iter_mut<'a>(&'a mut self) -> IterMut {
        self.samples.iter_mut()
    }

    pub fn find_within_sphere_mut<'a>(&'a mut self, center: Vector3<f32>, radius: f32) -> BoxedIterMut {
        let radius_sqr = radius * radius;
        Box::new(
            self.samples.iter_mut()
                .filter(move |s| s.position.distance2(center) < radius_sqr)
        )
    }
}

