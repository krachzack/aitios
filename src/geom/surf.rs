
use std::io;
use std::cmp::Ordering::Equal;
use ::cgmath::{Vector3};
use ::cgmath::prelude::*;
use ::rand;
use ::geom::tri::area;

/// Represents the surface of a mesh as a point-based model
pub struct Surface {
    pub samples: Vec<Surfel>
}

/// Represents an element of the surface of an object
pub struct Surfel {
    pub position: Vector3<f32>,
    /// Deterioration rate of the probability of a gammaton moving further in a straight line
    delta_straight: f32,
    /// Deterioration rate of the probability of a gammaton moving in a piecewise approximated parabolic path
    #[allow(dead_code)]
    delta_parabolic: f32,
    /// Deterioration rate of the probability of a gammaton flowing in a tangent direction
    #[allow(dead_code)]
    delta_flow: f32,
    /// Holds the amount of materials as numbers in the interval 0..1
    pub materials: Vec<f32>
}

pub struct SurfaceBuilder {
    samples: Vec<Surfel>,
    /// Initial deterioration rate of the probability of a gammaton moving further in a straight line
    delta_straight: f32,
    /// Initial deterioration rate of the probability of a gammaton moving in a piecewise approximated parabolic path
    #[allow(dead_code)]
    delta_parabolic: f32,
    /// Initial deterioration rate of the probability of a gammaton flowing in a tangent direction
    #[allow(dead_code)]
    delta_flow: f32,
    /// Holds the initial amount of materials as numbers in the interval 0..1
    materials: Vec<f32>
}

impl Surface {
    pub fn dump<S : io::Write>(&self, sink: &mut S) -> io::Result<usize> {
        let mut written : usize = 0;

        written += sink.write("# Surface Model\n".as_bytes())?;
        written += sink.write("# Generated by surf.rs\n\n".as_bytes())?;

        written += sink.write("g surface\n\n".as_bytes())?;

        for &point in self.samples.iter().map(|s| &s.position) {
            // Write all the points as vertices
            let vertex_line = format!("v {} {} {}\n", point.x, point.y, point.z);
            written += sink.write(vertex_line.as_bytes())?;
        }

        written += sink.write("\n".as_bytes())?;

        // OBJ indices are 1-based, hence +1
        for idx in (0+1)..(self.samples.len()+1) {
            // Write points as 1-dimensional faces
            let face_line = format!("f {}\n", idx);
            written += sink.write(face_line.as_bytes())?;
        }

        Ok(written)
    }

    pub fn nearest<'a>(&'a mut self, from: Vector3<f32>) -> &'a mut Surfel {
        let from = from.clone();
        self.samples.iter_mut().min_by(
            |a, b| {
                let dist_a = a.position.distance2(from);
                let dist_b = b.position.distance2(from);
                dist_a.partial_cmp(&dist_b).unwrap_or(Equal)
            }
        ).unwrap() // panics if samples is empty
    }
}

impl SurfaceBuilder {
    pub fn new() -> SurfaceBuilder {
        SurfaceBuilder {
            samples: Vec::new(),
            delta_straight: 0.0,
            delta_parabolic: 0.0,
            delta_flow: 0.0,
            materials: Vec::new()
        }
    }

    pub fn delta_straight(mut self, delta_straight: f32) -> SurfaceBuilder {
        self.delta_straight = delta_straight;
        self
    }

    #[allow(dead_code)]
    pub fn delta_parabolic(mut self, delta_parabolic: f32) -> SurfaceBuilder {
        self.delta_parabolic = delta_parabolic;
        self
    }

    #[allow(dead_code)]
    pub fn delta_flow(mut self, delta_flow: f32) -> SurfaceBuilder {
        self.delta_flow = delta_flow;
        self
    }

    /// Sets initial material composition of all surfels in the Surface built with this builder.
    pub fn materials(mut self, materials: Vec<f32>) -> SurfaceBuilder {
        self.materials = materials;
        self
    }

    pub fn add_surface_from_points<P>(mut self, points: P) -> SurfaceBuilder
    where
        P : IntoIterator<Item = Vector3<f32>> {

        let prototype_surfel = Surfel {
            position: Vector3::new(-1.0, -1.0, -1.0),
            delta_straight: self.delta_straight,
            delta_parabolic: self.delta_parabolic,
            delta_flow: self.delta_flow,
            materials: self.materials.clone()
        };

        let surfels = points.into_iter()
            .map(
                |position| Surfel {
                    position: position,
                    materials: prototype_surfel.materials.clone(),
                    ..prototype_surfel
                }
            );

        self.samples.extend(surfels);
        self
    }

    /// Creates a surface model by sampling an amount of random points on each
    /// of the traingles in the given indexed mesh that is proportional to the
    /// area of the individual triangles. This way, the sampling is sort of uniform
    /// but not really.
    ///
    /// The initial values of the surfels are provided to the builder before calling
    /// this method.
    pub fn add_surface_from_indexed_triangles(self, positions: &Vec<f32>, indices: &Vec<u32>, surfels_per_sqr_unit: f32) -> SurfaceBuilder {
        let triangles = indices.chunks(3)
            .map(
                |i| (
                    Vector3::new(positions[(3*i[0]+0) as usize], positions[(3*i[0]+1) as usize], positions[(3*i[0]+2) as usize]),
                    Vector3::new(positions[(3*i[1]+0) as usize], positions[(3*i[1]+1) as usize], positions[(3*i[1]+2) as usize]),
                    Vector3::new(positions[(3*i[2]+0) as usize], positions[(3*i[2]+1) as usize], positions[(3*i[2]+2) as usize])
                )
            );

        let surfel_positions = triangles.fold(
            Vec::new(),
            |mut acc, (v0, v1, v2)| {
                let surfel_count = (surfels_per_sqr_unit * area(v0, v1, v2)).ceil() as i32;

                for _ in 0..surfel_count {
                    let u = rand::random::<f32>();
                    let v = rand::random::<f32>();
                    let random_point = (1.0 - u.sqrt()) * v0 +
                                       (u.sqrt() * (1.0 - v)) * v1 +
                                       (u.sqrt() * v) * v2;

                    acc.push(random_point);
                }

                acc
            }
        );

        self.add_surface_from_points(surfel_positions)
    }

    /// Consumes the builder to create a new surface that is returned.
    pub fn build(self) -> Surface {
        Surface { samples: self.samples }
    }
}
