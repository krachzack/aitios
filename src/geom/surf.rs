
use std::io;

use ::cgmath::{Vector2, Vector3};
use ::rand;
use ::kdtree::kdtree::{Kdtree, KdtreePointTrait};

use super::scene::Scene;

/// Represents the surface of a mesh as a point-based model
pub struct Surface {
    pub samples: Vec<Surfel>,
    pub spatial_idx: Kdtree<SurfelIndex>
}

/// Represents an element of the surface of an object
pub struct Surfel {
    pub position: Vector3<f32>,
    pub texcoords: Vector2<f32>,
    /// Index of the entity in the scene that the triangle that this surfel was generated from belongs to
    pub entity_idx: usize,
    /// Deterioration rate of the probability of a gammaton moving further in a straight line
    #[allow(dead_code)]
    delta_straight: f32,
    /// Deterioration rate of the probability of a gammaton moving in a piecewise approximated parabolic path
    #[allow(dead_code)]
    delta_parabolic: f32,
    /// Deterioration rate of the probability of a gammaton flowing in a tangent direction
    #[allow(dead_code)]
    delta_flow: f32,
    /// Holds the amount of substances as numbers in the interval 0..1
    pub substances: Vec<f32>
}

/// Lightweight spatial index for the surfel
#[derive(PartialEq, Copy, Clone)]
pub struct SurfelIndex {
    position: [f64; 3],
    idx: Option<usize>
}

pub struct SurfaceBuilder {
    samples: Vec<Surfel>,
    /// Initial deterioration rate of the probability of a gammaton moving further in a straight line
    delta_straight: f32,
    /// Initial deterioration rate of the probability of a gammaton moving in a piecewise approximated parabolic path
    delta_parabolic: f32,
    /// Initial deterioration rate of the probability of a gammaton flowing in a tangent direction
    delta_flow: f32,
    /// Holds the initial amount of substances as numbers in the interval 0..1
    substances: Vec<f32>,
    surfels_per_sqr_unit: f32,
}

impl Surface {
    pub fn dump<S : io::Write>(&self, sink: &mut S) -> io::Result<usize> {
        let mut written : usize = 0;

        written += sink.write("# Surface Model\n".as_bytes())?;
        written += sink.write("# Generated by surf.rs\n\n".as_bytes())?;

        written += sink.write("g surface\n\n".as_bytes())?;

        for &point in self.samples.iter().map(|s| &s.position) {
            // Write all the points as vertices
            let vertex_line = format!("v {} {} {}\n", point.x, point.y, point.z);
            written += sink.write(vertex_line.as_bytes())?;
        }

        written += sink.write("\n".as_bytes())?;

        // OBJ indices are 1-based, hence +1
        for idx in (0+1)..(self.samples.len()+1) {
            // Write points as 1-dimensional faces
            let face_line = format!("f {}\n", idx);
            written += sink.write(face_line.as_bytes())?;
        }

        Ok(written)
    }

    pub fn nearest<'a>(&'a mut self, from: Vector3<f32>) -> &'a mut Surfel {
        assert!(!self.samples.is_empty());

        let SurfelIndex { idx: nearest_idx, position: _ } = {
            let x = from.x as f64;
            let y = from.y as f64;
            let z = from.z as f64;

            let lookup_idx = SurfelIndex {
                position: [x, y, z],
                idx: None
            };

            self.spatial_idx.nearest_search(&lookup_idx)
        };

        &mut self.samples[nearest_idx.unwrap()]
    }
}

impl SurfaceBuilder {
    pub fn new() -> SurfaceBuilder {
        SurfaceBuilder {
            samples: Vec::new(),
            delta_straight: 0.0,
            delta_parabolic: 0.0,
            delta_flow: 0.0,
            substances: Vec::new(),
            surfels_per_sqr_unit: 10000.0
        }
    }

    pub fn delta_straight(mut self, delta_straight: f32) -> SurfaceBuilder {
        self.delta_straight = delta_straight;
        self
    }

    #[allow(dead_code)]
    pub fn delta_parabolic(mut self, delta_parabolic: f32) -> SurfaceBuilder {
        self.delta_parabolic = delta_parabolic;
        self
    }

    #[allow(dead_code)]
    pub fn delta_flow(mut self, delta_flow: f32) -> SurfaceBuilder {
        self.delta_flow = delta_flow;
        self
    }

    /// Sets initial material composition of all surfels in the Surface built with this builder.
    pub fn substances(mut self, substances: &Vec<f32>) -> SurfaceBuilder {
        self.substances = substances.clone();
        self
    }

    pub fn surfels_per_sqr_unit(mut self, surfels_per_sqr_unit: f32) -> SurfaceBuilder {
        self.surfels_per_sqr_unit = surfels_per_sqr_unit;
        self
    }

    /// Creates a surface from only points
    /// Only useful for debugging, since you can make a surface and dump it.
    pub fn add_surface_from_points<P>(mut self, points: P) -> SurfaceBuilder
    where
        P : IntoIterator<Item = Vector3<f32>> {

        let prototype_surfel = Surfel {
            position: Vector3::new(-1.0, -1.0, -1.0),
            texcoords: Vector2::new(-1.0, -1.0),
            entity_idx: 0,
            delta_straight: self.delta_straight,
            delta_parabolic: self.delta_parabolic,
            delta_flow: self.delta_flow,
            substances: self.substances.clone()
        };

        let surfels = points.into_iter()
            .map(
                |position| Surfel {
                    position: position,
                    substances: prototype_surfel.substances.clone(),
                    ..prototype_surfel
                }
            );

        self.samples.extend(surfels);
        self
    }

    /// Creates a surface model by sampling an amount of random points on each
    /// of the traingles in the given indexed mesh that is proportional to the
    /// area of the individual triangles. This way, the sampling is sort of uniform
    /// but not really.
    ///
    /// The initial values of the surfels are provided to the builder before calling
    /// this method (not after).
    pub fn add_surface_from_scene(mut self, scene: &Scene) -> SurfaceBuilder {
        let delta_straight = self.delta_straight;
        let delta_parabolic = self.delta_parabolic;
        let delta_flow = self.delta_flow;
        let substances = self.substances.clone();

        let surfels_per_sqr_unit = self.surfels_per_sqr_unit;

        self.samples.extend(
            scene.triangles()
                .flat_map(|t| {
                    let surfel_count = (surfels_per_sqr_unit * t.area()).ceil() as i32;
                    let p0 = t.vertices[0].position;
                    let p1 = t.vertices[1].position;
                    let p2 = t.vertices[2].position;
                    let entity_idx = t.vertices[0].entity_idx;
                    let substances = substances.clone();

                    (0..surfel_count).map(move |_| {
                        let u = rand::random::<f32>();
                        let v = rand::random::<f32>();
                        let position = (1.0 - u.sqrt()) * p0 +
                                        (u.sqrt() * (1.0 - v)) * p1 +
                                        (u.sqrt() * v) * p2;

                        let mut texcoords = t.interpolate_at(
                            position,
                            |v| v.texcoords
                        );

                        // TODO maybe add warning if UVs degenerate
                        if texcoords.x < 0.0 {
                            texcoords.x = 0.0;
                        } else if texcoords.x > 1.0 {
                            texcoords.x = 1.0;
                        }

                        if texcoords.y < 0.0 {
                            texcoords.y = 0.0;
                        } else if texcoords.y > 1.0 {
                            texcoords.y = 1.0;
                        }

                        Surfel {
                            position,
                            texcoords,
                            entity_idx,
                            delta_straight: delta_straight,
                            delta_parabolic: delta_parabolic,
                            delta_flow: delta_flow,
                            substances: substances.clone()
                        }
                    })
                })
        );

        self
    }

    /// Consumes the builder to create a new surface that is returned.
    pub fn build(self) -> Surface {
        let spatial_idx = {
            let mut spatial_index_data : Vec<_> = self.samples.iter()
                .enumerate()
                .map(|(idx, s)| {
                    let idx = Some(idx);
                    let x = s.position.x as f64;
                    let y = s.position.y as f64;
                    let z = s.position.z as f64;
                    SurfelIndex { idx, position: [x, y, z] }
                })
                .collect();

            Kdtree::new(&mut spatial_index_data)
        };

        Surface { samples: self.samples, spatial_idx }
    }
}

impl KdtreePointTrait for SurfelIndex {
    #[inline] // the inline on this method is important! as without it there is ~25% speed loss on the tree when cross-crate usage.
    fn dims(&self) -> &[f64] {
        &self.position
    }
}

